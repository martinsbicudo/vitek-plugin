/**
 * TypeScript type generation for the API
 * Core logic - no Vite dependencies
 */

import * as fs from 'fs';
import * as path from 'path';
import type { RouteSchema } from './schema.js';
import { capitalize } from '../../shared/utils.js';

/**
 * Generates the content of the generated types file
 */
export function generateTypesContent(routes: RouteSchema[], apiBasePath: string): string {
  const imports = `// Auto-generated by Vitek - DO NOT EDIT
// This file is automatically generated from your API routes

export type VitekParams = Record<string, string>;
export type VitekQuery = Record<string, string | string[]>;
`;

  // Generate unique names for all types (Params, Body, Query)
  const typeNameMaps = generateUniqueTypeNames(routes);
  const paramTypeNameMap = typeNameMaps.params;
  const bodyTypeNameMap = typeNameMaps.body;
  const queryTypeNameMap = typeNameMaps.query;

  // Generate body types for routes that have body type declared
  const bodyTypes = routes
    .filter(route => route.bodyType)
    .map(route => {
      const routeKey = `${route.method}:${route.pattern}`;
      const bodyTypeName = bodyTypeNameMap.get(routeKey)!;
      // route.bodyType was already checked in the filter above, so it's not undefined
      const bodyType = route.bodyType!;
      // If bodyType already starts with '{', it means it's an extracted interface
      // If not, it's a type alias, so use it directly
      const bodyTypeDef = bodyType.trim().startsWith('{') 
        ? bodyType 
        : bodyType;
      return `export type ${bodyTypeName} = ${bodyTypeDef};`;
    })
    .filter((type, index, arr) => {
      // Remove duplicates based on type name
      const typeName = type.match(/^export type (\w+)/)?.[1];
      return typeName && arr.findIndex(t => t.match(/^export type (\w+)/)?.[1] === typeName) === index;
    })
    .join('\n\n');

  // Generate query types for routes that have query type declared
  const queryTypes = routes
    .filter(route => route.queryType)
    .map(route => {
      const routeKey = `${route.method}:${route.pattern}`;
      const queryTypeName = queryTypeNameMap.get(routeKey)!;
      // route.queryType was already checked in the filter above, so it's not undefined
      const queryType = route.queryType!;
      const queryTypeDef = queryType.trim().startsWith('{') 
        ? queryType 
        : queryType;
      return `export type ${queryTypeName} = ${queryTypeDef};`;
    })
    .filter((type, index, arr) => {
      // Remove duplicates based on type name
      const typeName = type.match(/^export type (\w+)/)?.[1];
      return typeName && arr.findIndex(t => t.match(/^export type (\w+)/)?.[1] === typeName) === index;
    })
    .join('\n\n');

  // Generate types for each route (params)
  const routeTypes = routes.map(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const typeName = paramTypeNameMap.get(routeKey)!;
    const paramsType = generateParamsType(route.params);
    
    return `export interface ${typeName} extends VitekParams {
${paramsType}
}`;
  })
  .filter((type, index, arr) => {
    // Remove duplicates based on type name
    const typeName = type.match(/^export interface (\w+)/)?.[1];
    return typeName && arr.findIndex(t => t.match(/^export interface (\w+)/)?.[1] === typeName) === index;
  })
  .join('\n\n');

  // Generate a type union with all routes
  const routeDefinitions = routes.map(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const typeName = paramTypeNameMap.get(routeKey)!;
    return `  | {
      pattern: '${route.pattern}';
      method: '${route.method}';
      params: ${typeName};
    }`;
  }).join('\n');

  const unionType = `export type VitekRoute =${routeDefinitions.length > 0 ? '\n' + routeDefinitions : ' never'};`;

  return `${imports}
${bodyTypes ? '\n' + bodyTypes + '\n' : ''}${queryTypes ? '\n' + queryTypes + '\n' : ''}
${routeTypes}

${unionType}

export const API_BASE_PATH = '${apiBasePath}' as const;
`;
}

/**
 * Generates unique names for all types (Params, Body, Query)
 * Ensures there are no collisions within and between categories
 */
function generateUniqueTypeNames(routes: RouteSchema[]): {
  params: Map<string, string>;
  body: Map<string, string>;
  query: Map<string, string>;
} {
  const paramNameMap = new Map<string, string>();
  const bodyNameMap = new Map<string, string>();
  const queryNameMap = new Map<string, string>();
  
  // All names already used (to ensure uniqueness between categories as well)
  const allUsedNames = new Set<string>();
  
  // Process Params types
  const paramGroups = new Map<string, RouteSchema[]>();
  routes.forEach(route => {
    const baseName = generateTypeNameBase(route, 'Params');
    if (!paramGroups.has(baseName)) {
      paramGroups.set(baseName, []);
    }
    paramGroups.get(baseName)!.push(route);
  });
  
  routes.forEach(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const baseName = generateTypeNameBase(route, 'Params');
    const conflictingRoutes = paramGroups.get(baseName)!;
    
    let uniqueName: string;
    if (conflictingRoutes.length === 1) {
      uniqueName = baseName;
    } else {
      uniqueName = generateUniqueTypeName(route, baseName, conflictingRoutes, allUsedNames, 'Params');
    }
    paramNameMap.set(routeKey, uniqueName);
    allUsedNames.add(uniqueName);
  });
  
  // Process Body types
  const bodyGroups = new Map<string, RouteSchema[]>();
  routes.filter(r => r.bodyType).forEach(route => {
    const baseName = generateTypeNameBase(route, 'Body');
    if (!bodyGroups.has(baseName)) {
      bodyGroups.set(baseName, []);
    }
    bodyGroups.get(baseName)!.push(route);
  });
  
  routes.filter(r => r.bodyType).forEach(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const baseName = generateTypeNameBase(route, 'Body');
    const conflictingRoutes = bodyGroups.get(baseName)!;
    
    let uniqueName: string;
    if (conflictingRoutes.length === 1) {
      uniqueName = baseName;
    } else {
      uniqueName = generateUniqueTypeName(route, baseName, conflictingRoutes, allUsedNames, 'Body');
    }
    bodyNameMap.set(routeKey, uniqueName);
    allUsedNames.add(uniqueName);
  });
  
  // Process Query types
  const queryGroups = new Map<string, RouteSchema[]>();
  routes.filter(r => r.queryType).forEach(route => {
    const baseName = generateTypeNameBase(route, 'Query');
    if (!queryGroups.has(baseName)) {
      queryGroups.set(baseName, []);
    }
    queryGroups.get(baseName)!.push(route);
  });
  
  routes.filter(r => r.queryType).forEach(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const baseName = generateTypeNameBase(route, 'Query');
    const conflictingRoutes = queryGroups.get(baseName)!;
    
    let uniqueName: string;
    if (conflictingRoutes.length === 1) {
      uniqueName = baseName;
    } else {
      uniqueName = generateUniqueTypeName(route, baseName, conflictingRoutes, allUsedNames, 'Query');
    }
    queryNameMap.set(routeKey, uniqueName);
    allUsedNames.add(uniqueName);
  });
  
  return {
    params: paramNameMap,
    body: bodyNameMap,
    query: queryNameMap,
  };
}

/**
 * Generates base type name from a route
 * Example: "users/:id" + "get" + "Params" -> "UsersIdGetParams"
 */
function generateTypeNameBase(route: RouteSchema, suffix: 'Params' | 'Body' | 'Query'): string {
  const parts = route.pattern
    .split('/')
    .filter(Boolean)
    .map(part => {
      // Remove : or * from the beginning
      const clean = part.replace(/^[:*]/, '');
      // Remove "index" from the end
      const withoutIndex = clean === 'index' ? '' : clean;
      // Capitalize each part
      return withoutIndex
        .split('-')
        .map(word => capitalize(word))
        .join('');
    });
  
  const patternPart = parts.filter(Boolean).join('');
  return patternPart + capitalize(route.method) + suffix;
}

/**
 * Generates a unique type name when there's a collision
 */
function generateUniqueTypeName(
  route: RouteSchema,
  baseName: string,
  conflictingRoutes: RouteSchema[],
  allUsedNames: Set<string>,
  suffix: 'Params' | 'Body' | 'Query'
): string {
  // Get all parts of the pattern (including parameters for context)
  const patternParts = route.pattern.split('/').filter(Boolean);
  
  // Remove "index" but keep all other parts (including params)
  const allParts = patternParts
    .filter(part => part !== 'index')
    .map(part => {
      // Include params in name to differentiate better
      const clean = part.replace(/^[:*]/, '');
      return capitalize(clean);
    });
  
  // Use all parts of the path to ensure uniqueness
  if (allParts.length > 0) {
    const fullPathName = allParts.join('');
    const candidate = fullPathName + capitalize(route.method) + suffix;
    
    if (!allUsedNames.has(candidate)) {
      return candidate;
    }
  }
  
  // If it still collides, try adding suffix with the last parts
  for (let i = allParts.length; i > 0; i--) {
    const suffixParts = allParts.slice(-i).join('');
    if (suffixParts) {
      const candidate = `${baseName}${suffixParts}`;
      if (!allUsedNames.has(candidate)) {
        return candidate;
      }
    }
  }
  
  // Last resort: add numeric suffix
  let counter = 1;
  let uniqueName = `${baseName}${counter}`;
  while (allUsedNames.has(uniqueName)) {
    counter++;
    uniqueName = `${baseName}${counter}`;
  }
  
  return uniqueName;
}

/**
 * Generates the params definition for a type
 */
function generateParamsType(params: string[]): string {
  if (params.length === 0) {
    return '  // No dynamic params';
  }
  
  return params.map(param => `  ${param}: string;`).join('\n');
}

/**
 * Writes the generated types file
 */
export async function generateTypesFile(
  outputPath: string,
  routes: RouteSchema[],
  apiBasePath: string
): Promise<void> {
  const content = generateTypesContent(routes, apiBasePath);
  
  // Create directory if it doesn't exist
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  fs.writeFileSync(outputPath, content, 'utf-8');
}

/**
 * Generates the content of the generated services file
 */
export function generateServicesContent(routes: RouteSchema[], apiBasePath: string, isTypeScript: boolean = true): string {
  // Generate unique names for all types (even in JS, we use them for parameter names)
  const uniqueTypeNames = generateUniqueTypeNames(routes);
  const paramTypeNameMap = uniqueTypeNames.params;
  const bodyTypeNameMap = uniqueTypeNames.body;
  const queryTypeNameMap = uniqueTypeNames.query;

  // Imports and constants
  let imports = '';
  let apiBasePathConstant = '';
  
  if (isTypeScript) {
    // Collect all types needed to import (using unique names)
    const paramTypeNames = Array.from(new Set(
      routes
        .filter(route => route.params.length > 0)
        .map(route => {
          const routeKey = `${route.method}:${route.pattern}`;
          return paramTypeNameMap.get(routeKey)!;
        })
    ));
    
    const bodyTypeNames = Array.from(new Set(
      routes
        .filter(route => route.bodyType)
        .map(route => {
          const routeKey = `${route.method}:${route.pattern}`;
          return bodyTypeNameMap.get(routeKey)!;
        })
    ));
    
    const queryTypeNames = Array.from(new Set(
      routes
        .filter(route => route.queryType)
        .map(route => {
          const routeKey = `${route.method}:${route.pattern}`;
          return queryTypeNameMap.get(routeKey)!;
        })
    ));
    
    const allTypeNames = [...paramTypeNames, ...bodyTypeNames, ...queryTypeNames];
    const typeImports = allTypeNames.length > 0
      ? `import type { ${allTypeNames.join(', ')} } from './api.types.js';\n`
      : '';
    
    imports = `// Auto-generated by Vitek - DO NOT EDIT
// This file is automatically generated from your API routes

import { API_BASE_PATH } from './api.types.js';
${typeImports}
`;
  } else {
    // JavaScript: no type imports, just constant
    imports = `// Auto-generated by Vitek - DO NOT EDIT
// This file is automatically generated from your API routes

const API_BASE_PATH = '${apiBasePath}';
`;
  }

  // Generate function for each route with unique names
  const functionNameMap = generateUniqueFunctionNames(routes);
  
  const functions = routes.map(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const functionName = functionNameMap.get(routeKey)!;
    const typeName = paramTypeNameMap.get(routeKey)!;
    const bodyTypeName = route.bodyType ? bodyTypeNameMap.get(routeKey) : undefined;
    const queryTypeName = route.queryType ? queryTypeNameMap.get(routeKey) : undefined;
    const urlPath = generateUrlPath(route.pattern, route.params);
    
    // Determine function parameters - only add if they actually exist
    const hasParams = route.params.length > 0;
    const hasBody = !!route.bodyType; // Only if bodyType is declared
    const hasQuery = !!route.queryType; // Only if queryType is declared
    const methodLower = route.method.toLowerCase();
    
    let params: string[] = [];
    let returnType = isTypeScript ? ': Promise<any>' : '';
    
    // Add params only if they exist
    if (hasParams) {
      if (isTypeScript) {
        params.push(`params: ${typeName}`);
      } else {
        params.push(`params`);
      }
    }
    
    // Add body only if bodyType is declared
    if (hasBody) {
      if (isTypeScript) {
        params.push(`body: ${bodyTypeName}`);
      } else {
        params.push(`body`);
      }
    }
    
    // Add query only if queryType is declared
    if (hasQuery) {
      if (isTypeScript) {
        params.push(`query: ${queryTypeName}`);
      } else {
        params.push(`query`);
      }
    }
    
    // Always add options
    if (isTypeScript) {
      params.push(`options?: RequestInit`);
    } else {
      params.push(`options`);
    }
    
    // Build fetch code
    let fetchCode = '';
    if (hasBody && hasQuery) {
      // POST, PUT, PATCH with body and query string
      fetchCode = `  const url = new URL(\`\${API_BASE_PATH}${urlPath}\`, window.location.origin);
  Object.entries(query).forEach(([key, value]) => {
    url.searchParams.append(key, String(value));
  });
  return fetch(url.pathname + url.search, {
    method: '${route.method.toUpperCase()}',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(body),
    ...options,
  }).then(res => res.json());`;
    } else if (hasBody) {
      // POST, PUT, PATCH with body (no query)
      fetchCode = `  return fetch(\`\${API_BASE_PATH}${urlPath}\`, {
    method: '${route.method.toUpperCase()}',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(body),
    ...options,
  }).then(res => res.json());`;
    } else if (hasQuery) {
      // GET (or other method) with typed query string (no body)
      fetchCode = `  const url = new URL(\`\${API_BASE_PATH}${urlPath}\`, window.location.origin);
  Object.entries(query).forEach(([key, value]) => {
    url.searchParams.append(key, String(value));
  });
  return fetch(url.pathname + url.search, {
    method: '${route.method.toUpperCase()}',
    ...options,
  }).then(res => res.json());`;
    } else {
      // GET/DELETE/etc without body or query
      fetchCode = `  return fetch(\`\${API_BASE_PATH}${urlPath}\`, {
    method: '${route.method.toUpperCase()}',
    ...options,
  }).then(res => res.json());`;
    }
    
    return `export async function ${functionName}(${params.join(', ')})${returnType} {
${fetchCode}
}`;
  }).join('\n\n');

  return `${imports}${functions}
`;
}

/**
 * Generates unique function names for all routes, ensuring there are no collisions
 */
function generateUniqueFunctionNames(routes: RouteSchema[]): Map<string, string> {
  const nameMap = new Map<string, string>(); // routeKey -> functionName
  const nameToRoutes = new Map<string, RouteSchema[]>(); // functionName -> routes[]
  
  // First pass: group routes by base name
  routes.forEach(route => {
    const baseName = generateFunctionNameBase(route);
    
    if (!nameToRoutes.has(baseName)) {
      nameToRoutes.set(baseName, []);
    }
    nameToRoutes.get(baseName)!.push(route);
  });
  
  // Second pass: resolve collisions
  routes.forEach(route => {
    const routeKey = `${route.method}:${route.pattern}`;
    const baseName = generateFunctionNameBase(route);
    
    const routesWithSameName = nameToRoutes.get(baseName)!;
    
    if (routesWithSameName.length === 1) {
      // Unique name, use directly
      nameMap.set(routeKey, baseName);
    } else {
      // There's a collision, we need to make it unique by including more context
      const uniqueName = generateUniqueFunctionName(route, baseName, routesWithSameName, nameMap);
      nameMap.set(routeKey, uniqueName);
    }
  });
  
  return nameMap;
}

/**
 * Generates base function name from a route
 * Example: "users/:id" + "get" -> "getUsersById"
 * Example: "posts/index" + "get" -> "getPosts" (index is removed)
 * Example: "" + "get" -> "get" (root route)
 */
function generateFunctionNameBase(route: RouteSchema): string {
  const method = route.method.toLowerCase();
  
  if (route.pattern === '') {
    // Rota raiz
    return method;
  }
  
  const parts = route.pattern
    .split('/')
    .filter(Boolean)
    .filter(part => part !== 'index') // Remove "index" from function name
    .map(part => {
      // Remove : or * from the beginning
      const clean = part.replace(/^[:*]/, '');
      // Capitalize
      return capitalize(clean);
    });
  
  const pathName = parts.join('');
  return `${method}${pathName}`;
}

/**
 * Generates a unique function name when there's a collision
 * Includes more context from the pattern to differentiate
 */
function generateUniqueFunctionName(
  route: RouteSchema,
  baseName: string,
  conflictingRoutes: RouteSchema[],
  existingNames: Map<string, string>
): string {
  // Get all parts of the pattern (including parameters as context)
  const patternParts = route.pattern.split('/').filter(Boolean);
  
  // Remove "index" but keep other parts (including params for context)
  const allParts = patternParts
    .filter(part => part !== 'index')
    .map(part => {
      // For parameters, include the name as context to differentiate
      // Example: ":id" becomes "Id", "*ids" becomes "Ids"
      const clean = part.replace(/^[:*]/, '');
      return capitalize(clean);
    });
  
  // Use all parts of the path to ensure uniqueness from the start
  if (allParts.length > 0) {
    const fullPathName = allParts.join('');
    const candidate = `${route.method.toLowerCase()}${fullPathName}`;
    
    // Check if this name has already been assigned to another route
    const usedNames = new Set(existingNames.values());
    if (!usedNames.has(candidate)) {
      return candidate;
    }
  }
  
  // If it still collides, try adding suffix with the last different parts
  // Compare with other conflicting routes to find differences
  const otherPatterns = conflictingRoutes
    .filter(r => r.pattern !== route.pattern)
    .map(r => r.pattern.split('/').filter(Boolean));
  
  // Try using more parts from the end of the path
  for (let i = allParts.length; i > 0; i--) {
    const suffix = allParts.slice(-i).join('');
    if (suffix) {
      const candidate = `${baseName}${suffix}`;
      const usedNames = new Set(existingNames.values());
      if (!usedNames.has(candidate)) {
        return candidate;
      }
    }
  }
  
  // Last resort: add sequential numeric suffix
  let counter = 1;
  let uniqueName = `${baseName}${counter}`;
  const usedNames = new Set(existingNames.values());
  
  while (usedNames.has(uniqueName)) {
    counter++;
    uniqueName = `${baseName}${counter}`;
  }
  
  return uniqueName;
}

/**
 * Generates the URL path by replacing params with template literals
 * Example: "users/:id" -> "/users/${params.id}"
 * Example: "posts/index" -> "/posts" (index is removed)
 * Example: "" -> "/"
 */
function generateUrlPath(pattern: string, params: string[]): string {
  if (pattern === '') {
    return '/';
  }
  
  // Remove "index" from the end of pattern if it exists
  let cleanPattern = pattern.replace(/\/index$/, '').replace(/^index\//, '');
  if (cleanPattern === 'index') {
    cleanPattern = '';
  }
  
  if (cleanPattern === '') {
    return '/';
  }
  
  let urlPath = '/' + cleanPattern;
  
  // Substitui :param por ${params.param}
  // Substitui *param por ${params.param} (catch-all)
  params.forEach(param => {
    // Para catch-all (*param), substitui o *param
    const catchAllPattern = `*${param}`;
    if (urlPath.includes(catchAllPattern)) {
      urlPath = urlPath.replace(catchAllPattern, `\${params.${param}}`);
    } else {
      // Para par√¢metro normal (:param)
      urlPath = urlPath.replace(`:${param}`, `\${params.${param}}`);
    }
  });
  
  return urlPath;
}

/**
 * Writes the generated services file
 */
export async function generateServicesFile(
  outputPath: string,
  routes: RouteSchema[],
  apiBasePath: string,
  isTypeScript: boolean = true
): Promise<void> {
  const content = generateServicesContent(routes, apiBasePath, isTypeScript);
  
  // Create directory if it doesn't exist
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  fs.writeFileSync(outputPath, content, 'utf-8');
}

